<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Reactive Pixel Art Space Animation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 100% !important;
            height: 100vh !important;
            position: absolute;
            top: 0;
            left: 0;
            animation: subtle-pulse 15s infinite alternate ease-in-out;
            z-index: 0;
        }
        @keyframes subtle-pulse {
            0% {
                filter: hue-rotate(0deg) brightness(1);
            }
            50% {
                filter: hue-rotate(10deg) brightness(1.05);
            }
            100% {
                filter: hue-rotate(-5deg) brightness(0.95);
            }
        }
        
        /* Scientific diagram annotation styles */
        .annotation {
            position: absolute;
            font-family: 'VT323', monospace;
            color: rgba(255, 255, 255, 0.9);
            z-index: 5;
            pointer-events: auto; /* Change to auto to enable hover */
            transition: opacity 0.5s ease;
            font-size: 16px;
            line-height: 1.4;
            width: 250px;
            text-align: left;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.9);
            image-rendering: pixelated;
            white-space: nowrap;
            cursor: pointer; /* Add cursor pointer to indicate interactivity */
        }
        
        /* Audio start button */
        .start-audio {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid rgba(255, 255, 255, 0.8);
            color: white;
            padding: 20px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            border-radius: 0px;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), 0 0 40px rgba(255, 0, 128, 0.3);
            transition: all 0.3s ease;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            animation: pulsate 2s infinite alternate;
            image-rendering: pixelated;
            letter-spacing: 1px;
        }
        
        .start-audio:hover {
            background: rgba(40, 40, 40, 0.8);
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.6), 0 0 50px rgba(255, 0, 128, 0.4);
            animation: none;
        }
        
        .interaction-note {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-family: 'VT323', monospace;
            font-size: 18px;
            text-align: center;
            width: 80%;
            max-width: 500px;
            margin-top: 20px;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.9);
            pointer-events: none;
            z-index: 999;
            letter-spacing: 1px;
            image-rendering: pixelated;
        }
        
        @keyframes pulsate {
            0% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), 0 0 40px rgba(255, 0, 128, 0.3);
            }
            100% {
                transform: translate(-50%, -50%) scale(1.1);
                box-shadow: 0 0 25px rgba(0, 0, 0, 0.6), 0 0 50px rgba(255, 0, 128, 0.5);
            }
        }
        
        .annotation-line {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            height: 1px;
            transform-origin: 0 0;
            z-index: 4;
            pointer-events: none;
            box-shadow: 0 0 3px rgba(255, 255, 255, 0.7);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .annotation-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #fff;
            border-radius: 50%;
            z-index: 5;
            pointer-events: none;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
            display: none; /* Hide the dot */
        }
        
        .annotation-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            margin-bottom: 8px;
            color: #ff9ec3;
            text-transform: uppercase;
            letter-spacing: 1px;
            line-height: 1.4;
            image-rendering: pixelated;
            white-space: nowrap;
        }
        
        .annotation-subtitle {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            margin-top: 4px;
            margin-bottom: 4px;
            color: #d2ebff;
            opacity: 0.9;
            line-height: 1.4;
            image-rendering: pixelated;
            white-space: nowrap;
        }
        
        .annotation-details {
            font-family: 'VT323', monospace;
            margin-top: 6px;
            font-size: 16px;
            opacity: 0.8;
            letter-spacing: 1px;
            image-rendering: pixelated;
            white-space: nowrap;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            color: white;
            font-family: 'VT323', monospace;
            font-size: 16px;
            letter-spacing: 1px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
            padding: 15px;
            image-rendering: pixelated;
        }
        
        body:hover .controls {
            opacity: 1;
        }
        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #444;
        }
        button.active {
            background: #1a6fb5;
            border-color: #2a8fd5;
        }
        .visualizer {
            width: 200px;
            height: 30px;
            background: #111;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }
        .level {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #33aaff, #bb33ff);
            transition: width 0.1s;
        }
        .status {
            margin-left: 10px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            opacity: 0.8;
            letter-spacing: 1px;
            image-rendering: pixelated;
        }
        #audioVideo {
            display: none; /* Hide video element but still use it for audio */
        }
    </style>
</head>
<body>
    <!-- Scientific annotation elements -->
    <div id="annotation" class="annotation">
        <div class="annotation-title">WITCHY & WOBBLE</div>
        <div class="annotation-subtitle">DJ AIRWALK</div>
        <div class="annotation-details">PLUSH120 â€¢ 2025</div>
    </div>
    <div id="annotationLine" class="annotation-line"></div>
    <div id="annotationDot" class="annotation-dot"></div>
    
    <!-- Start audio button (required due to browser autoplay policies) -->
    <button id="startAudioBtn" class="start-audio">CLICK TO START AUDIO</button>
    <div id="interactionNote" class="interaction-note">Browsers require user interaction before playing audio.<br>Click the button to begin the full audio-visual experience.</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main configuration parameters
        const CONFIG = {
            pixelSize: 4,          // Size of each "pixel" in our pixel art
            starCount: 600,        // Further increased star count for more immersive effect
            starSpeed: 0.6,        // Dramatically increased speed for faster space travel effect
            particleCount: 150,    // Number of particles for the breaking apart effect
            bpm: 170,              // Fallback BPM for animation sync if no audio
            beatDuration: 60000 / 170, // Duration of one beat in ms
            explosionFrequency: 0.005, // Reduced chance of star explosion for calmer feel
            objectPulseAmount: 0.35,   // Increased pulse amount for more pronounced effect
            audioReactivity: 0.6,  // How much the audio affects the animation (0-1)
            resolution: {          // Render resolution
                width: 200,        // 200 * pixelSize = 800px
                height: 150        // 150 * pixelSize = 600px
            },
            audioUrl: "https://cdn-prod-1.labelgrid.com/labels/plushrecs/320/20574c2e-ffac-4a35-8953-eabab0875919.mp3?ts=1740653528", // Audio stream URL
            audioThresholds: {
                bass: [20, 150],    // Bass frequency range
                mid: [150, 2000],   // Mid frequency range
                high: [2000, 16000] // High frequency range
            }
        };

        // Calculate beat timing (fallback)
        const BEAT_INTERVAL = 60 / CONFIG.bpm;

        // Scene setup
        let scene, camera, renderer, clock;
        let cameraZoom = 5; // Initial camera zoom level
        let starField, centerObject;
        let lastBeat = 0;

        // Audio setup
        let audioContext, audioAnalyser, audioSource, dataArray, audioInitialized = false;
        let bassEnergy = 0, midEnergy = 0, highEnergy = 0, beatDetected = false;
        let audioLevel = 0, smoothedLevel = 0, beatHistory = [];
        let videoElement = null;
        let demoMode = false;
        let demoData = {
            bassPattern: [],
            midPattern: [],
            highPattern: [],
            beatPattern: [],
            time: 0
        };
        
        // Particle system for star debris
        let particleSystem;
        let particleData = [];
        
        // Initialize the scene
        function init() {
            // Create main scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 1000); // Wider field of view
            camera.position.z = cameraZoom; // Use the cameraZoom variable
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Add window resize handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Setup clock for animations
            clock = new THREE.Clock();
            
            // Add mouse wheel event listener for camera zoom control
            window.addEventListener('wheel', handleMouseWheel, { passive: false });
            
            // Add touch events for pinch zoom on mobile devices
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Create stars
            createStars();
            
            // Create star debris particle system
            createParticleSystem();
            
            // Create center object
            createCenterObject();
            
            // Create UI elements
            createUIElements();
            
            // Start in demo mode by default
            startDemoMode();
            
            // Set up click handler for the start audio button
            document.getElementById('startAudioBtn').addEventListener('click', function(event) {
                // Start the real audio stream
                startAudio();
                
                // Prevent default and stop propagation
                event.preventDefault();
                event.stopPropagation();
            });
            
            // Start animation loop
            animate();
        }

        // Initialize the scientific annotation
        function initializeAnnotation() {
            // Position annotation text to the left of the center object
            const annotation = document.getElementById('annotation');
            annotation.style.top = '37%';
            annotation.style.left = '6%';
            annotation.style.right = 'auto';
            annotation.style.transform = 'translateY(-50%)';
            
            // Initially position the dot and line
            const dot = document.getElementById('annotationDot');
            const line = document.getElementById('annotationLine');
            dot.style.top = '50%';
            dot.style.left = '50%';
            line.style.top = '50%';
            line.style.left = '50%';
            line.style.opacity = '0'; // Ensure line starts hidden
            
            // Create a circular hover area around the center object
            const hoverArea = document.createElement('div');
            hoverArea.id = 'objectHoverArea';
            hoverArea.style.position = 'absolute';
            hoverArea.style.width = '200px';
            hoverArea.style.height = '200px';
            hoverArea.style.borderRadius = '50%';
            hoverArea.style.zIndex = '3';
            hoverArea.style.cursor = 'pointer';
            hoverArea.style.background = 'transparent'; // Invisible
            document.body.appendChild(hoverArea);
            
            // Function to position hover area around center object
            function updateHoverAreaPosition() {
                if (!centerObject) return;
                const vector = new THREE.Vector3();
                vector.setFromMatrixPosition(centerObject.matrixWorld);
                vector.project(camera);
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                hoverArea.style.left = (x - 100) + 'px'; // Center the hover area (half of 200px width)
                hoverArea.style.top = (y - 100) + 'px';
            }
            
            // Update the hover area position with animation
            function animateHoverArea() {
                updateHoverAreaPosition();
                requestAnimationFrame(animateHoverArea);
            }
            animateHoverArea();
            
            // Also update hover area position when camera moves
            const canvas = document.querySelector('canvas');
            canvas.addEventListener('mousemove', updateHoverAreaPosition);
            
            // Show line on annotation hover
            annotation.addEventListener('mouseenter', () => {
                line.style.opacity = '1';
            });
            
            annotation.addEventListener('mouseleave', () => {
                line.style.opacity = '0';
            });
            
            // Show line on object hover area
            hoverArea.addEventListener('mouseenter', () => {
                line.style.opacity = '1';
            });
            
            hoverArea.addEventListener('mouseleave', () => {
                line.style.opacity = '0';
            });
        }
        
        // Update annotation position to point at the center object
        function updateAnnotation() {
            if (!centerObject) return;
            
            // Get the center object's position in 3D space
            const vector = new THREE.Vector3();
            vector.setFromMatrixPosition(centerObject.matrixWorld);
            
            // Project 3D position to 2D screen position
            vector.project(camera);
            
            // Convert to screen coordinates
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
            
            // Don't position the dot as we're hiding it
            // const dot = document.getElementById('annotationDot');
            // dot.style.left = x + 'px';
            // dot.style.top = y + 'px';
            
            // Get the annotation position
            const annotation = document.getElementById('annotation');
            const annotRect = annotation.getBoundingClientRect();
            const lineStartX = annotRect.right; // Start from right side of annotation
            const lineStartY = annotRect.top + annotRect.height * 0.5; // middle of annotation
            
            // Position the line
            const line = document.getElementById('annotationLine');
            const length = Math.sqrt(Math.pow(x - lineStartX, 2) + Math.pow(y - lineStartY, 2));
            const angle = Math.atan2(y - lineStartY, x - lineStartX);
            
            line.style.width = length + 'px';
            line.style.left = lineStartX + 'px';
            line.style.top = lineStartY + 'px';
            line.style.transform = `rotate(${angle}rad)`;
            
            // Make annotation pulse with audio energy if we have audio data
            if (audioContext && smoothedLevel > 0) {
                const scaleFactor = 1 + (smoothedLevel * 0.1); // subtle pulse
                annotation.style.transform = `translateY(-50%) scale(${scaleFactor})`;
                line.style.height = (1 + smoothedLevel * 0.5) + 'px';
            }
        }
        
        // Initialize audio after user interaction
        function startAudio() {
            // Remove the start button and interaction note
            const startBtn = document.getElementById('startAudioBtn');
            const interactionNote = document.getElementById('interactionNote');
            
            if (startBtn) {
                startBtn.style.opacity = '0';
                setTimeout(() => {
                    startBtn.style.display = 'none';
                }, 500);
            }
            
            if (interactionNote) {
                interactionNote.style.opacity = '0';
                setTimeout(() => {
                    interactionNote.style.display = 'none';
                }, 500);
            }
            
            // Stop demo mode if it's running
            if (demoMode) {
                stopDemoMode();
            }
            
            // Initialize audio context if not already done
            if (!audioContext) {
                try {
                    document.querySelector('.status').textContent = 'Connecting to audio...';                    
                    initStreamAudio();
                } catch (e) {
                    console.error('Error starting audio:', e);
                    // Show error message
                    document.querySelector('.status').textContent = 'Audio error - using demo';  
                    startDemoMode();
                }
            } else if (audioContext.state === 'suspended') {
                // Resume audio context if it was suspended
                audioContext.resume().then(() => {
                    document.querySelector('.status').textContent = 'Audio resumed';
                }).catch(err => {
                    console.error('Failed to resume audio context:', err);
                });
            }
            
            // Also try to play the video element if it exists and is paused
            if (videoElement && videoElement.paused) {
                videoElement.play().catch(err => {
                    console.error('Failed to play video element:', err);
                });
            }
        }
        
        // Create UI elements
        function createUIElements() {
            const controls = document.createElement('div');
            controls.className = 'controls';
            
            // Create hidden video element for audio stream
            videoElement = document.createElement('video');
            videoElement.id = 'audioVideo';
            videoElement.setAttribute('crossorigin', 'anonymous');
            videoElement.setAttribute('autoplay', ''); // Add autoplay attribute
            videoElement.setAttribute('muted', ''); // Initially muted to bypass browser restrictions
            videoElement.setAttribute('playsinline', ''); // Better compatibility for mobile
            document.body.appendChild(videoElement);
            
            // Demo mode button
            const demoButton = document.createElement('button');
            demoButton.textContent = 'Start Demo Mode';
            demoButton.addEventListener('click', () => {
                if (demoMode) {
                    stopDemoMode();
                    demoButton.textContent = 'Start Demo Mode';
                    demoButton.classList.remove('active');
                } else {
                    disconnectAudio();
                    startDemoMode();
                    demoButton.textContent = 'Stop Demo Mode';
                    demoButton.classList.add('active');
                    streamButton.textContent = 'Try Real Stream';
                    streamButton.classList.remove('active');
                }
            });
            
            // Stream button
            const streamButton = document.createElement('button');
            streamButton.textContent = 'Try Real Stream';
            streamButton.addEventListener('click', () => {
                if (audioInitialized && !demoMode) {
                    disconnectAudio();
                    streamButton.textContent = 'Try Real Stream';
                    streamButton.classList.remove('active');
                } else {
                    stopDemoMode();
                    initStreamAudio();
                    streamButton.textContent = 'Disconnect Stream';
                    streamButton.classList.add('active');
                    demoButton.textContent = 'Start Demo Mode';
                    demoButton.classList.remove('active');
                }
            });
            
            // Audio level visualizer
            const visualizer = document.createElement('div');
            visualizer.className = 'visualizer';
            
            const level = document.createElement('div');
            level.className = 'level';
            visualizer.appendChild(level);
            
            // Status indicator
            const status = document.createElement('div');
            status.className = 'status';
            status.textContent = 'No audio connected';
            
            // Add elements to controls
            controls.appendChild(demoButton);
            controls.appendChild(streamButton);
            controls.appendChild(visualizer);
            controls.appendChild(status);
            document.body.appendChild(controls);
            
            // Initialize demo patterns
            initDemoPatterns();
        }
        
        // Initialize demo audio patterns
        function initDemoPatterns() {
            // Create patterns for each frequency range
            
            // Bass pattern (very gentle and slow waves)
            const bassLength = 200; // Longer pattern for more gradual changes
            for (let i = 0; i < bassLength; i++) {
                // Create a smooth, gentle bass pattern
                const bassBeat = 0.2 + 0.15 * Math.sin(i * 0.03) + 0.1 * Math.sin(i * 0.01);
                demoData.bassPattern.push(bassBeat);
                
                // Very occasional subtle beat pattern
                demoData.beatPattern.push(i % 32 === 0 ? true : false);
            }
            
            // Mid pattern (slow, ambient changes)
            const midLength = 180;
            for (let i = 0; i < midLength; i++) {
                // Gentle waves in mid frequencies
                const midValue = 0.2 + 0.15 * Math.sin(i * 0.02) + 0.1 * Math.sin(i * 0.05);
                demoData.midPattern.push(midValue);
            }
            
            // High pattern (soft ambient shimmer)
            const highLength = 160;
            for (let i = 0; i < highLength; i++) {
                // Subtle, slow-changing high frequencies
                const highValue = 0.1 + 0.15 * Math.sin(i * 0.03) + 0.05 * Math.sin(i * 0.07);
                demoData.highPattern.push(highValue);
            }
        }
        
        // Start demo mode with synthetic audio data
        function startDemoMode() {
            demoMode = true;
            audioInitialized = false;
            demoData.time = 0;
            document.querySelector('.status').textContent = 'Demo mode active';
        }
        
        // Stop demo mode
        function stopDemoMode() {
            if (demoMode) {
                demoMode = false;
                document.querySelector('.status').textContent = 'No audio connected';
            }
        }
        
        // Disconnect current audio source
        function disconnectAudio() {
            if (audioInitialized && audioSource) {
                try {
                    // Stop video element
                    if (videoElement) {
                        videoElement.pause();
                        videoElement.src = '';
                        videoElement.load();
                    }
                    
                    // Disconnect from audio graph
                    audioSource.disconnect();
                    audioAnalyser.disconnect();
                    
                    // Close audio context if possible
                    if (audioContext && audioContext.state !== 'closed') {
                        audioContext.close().catch(e => console.log('Error closing audio context:', e));
                    }
                } catch (e) {
                    console.error('Error disconnecting audio:', e);
                }
                
                audioInitialized = false;
                document.querySelector('.status').textContent = 'No audio connected';
            }
        }
        
        // Initialize stream audio using video element
        function initStreamAudio() {
            try {
                // Create audio context
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create analyzer
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 2048;
                audioAnalyser.smoothingTimeConstant = 0.85;
                
                // Get buffer size and create data array
                const bufferLength = audioAnalyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                // Set up the video element for audio streaming
                videoElement.setAttribute('crossorigin', 'anonymous');
                videoElement.src = CONFIG.audioUrl;
                videoElement.load();
                
                // Add error handling
                videoElement.onerror = (e) => {
                    console.error('Video element error:', e);
                    document.querySelector('.status').textContent = 'Stream unavailable';
                };
                
                // Create source from video element
                audioSource = audioContext.createMediaElementSource(videoElement);
                audioSource.connect(audioAnalyser);
                audioAnalyser.connect(audioContext.destination);
                
                // Play video (for audio)
                const playPromise = videoElement.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        document.querySelector('.status').textContent = 'Stream connected';
                        audioInitialized = true;
                    }).catch(error => {
                        console.error('Audio playback failed:', error);
                        
                        // Try with user interaction
                        document.querySelector('.status').textContent = 'Click again to connect';
                        
                        // Try a different approach with audio element as fallback
                        tryFallbackAudio();
                    });
                }
            } catch (error) {
                console.error('Error initializing audio:', error);
                document.querySelector('.status').textContent = 'Audio initialization error';
                tryFallbackAudio();
            }
        }
        
        // Try a fallback approach with audio element
        function tryFallbackAudio() {
            try {
                // Clean up previous attempt
                if (audioSource) {
                    audioSource.disconnect();
                }
                
                if (audioAnalyser) {
                    audioAnalyser.disconnect();
                }
                
                // Try with an audio element instead
                const audioElement = document.createElement('audio');
                audioElement.crossOrigin = 'anonymous';
                audioElement.src = CONFIG.audioUrl;
                document.body.appendChild(audioElement);
                
                // Add CORS headers via fetch first
                fetch(CONFIG.audioUrl, {
                    method: 'GET',
                    mode: 'cors',
                    headers: {
                        'Origin': window.location.origin
                    }
                })
                .then(response => {
                    audioElement.play()
                    .then(() => {
                        audioSource = audioContext.createMediaElementSource(audioElement);
                        audioSource.connect(audioAnalyser);
                        audioAnalyser.connect(audioContext.destination);
                        
                        document.querySelector('.status').textContent = 'Stream connected (fallback)';
                        audioInitialized = true;
                    })
                    .catch(error => {
                        console.error('Fallback audio failed:', error);
                        document.querySelector('.status').textContent = 'Could not connect to stream';
                    });
                })
                .catch(error => {
                    console.error('Fetch failed:', error);
                    document.querySelector('.status').textContent = 'Stream connection failed';
                });
            } catch (error) {
                console.error('Fallback audio error:', error);
                document.querySelector('.status').textContent = 'Stream unavailable';
            }
        }
        
        // Analyze audio data or generate demo data
        function analyzeAudio() {
            // If in demo mode, generate synthetic audio data
            if (demoMode) {
                // Update time counter at a slower pace for more mellow feel
                demoData.time = (demoData.time + 0.5) % 10000; // Half speed for gentler transitions
                
                // Get current values from patterns using modulo to cycle through them
                const bassIndex = Math.floor(demoData.time) % demoData.bassPattern.length;
                const midIndex = Math.floor(demoData.time) % demoData.midPattern.length;
                const highIndex = Math.floor(demoData.time) % demoData.highPattern.length;
                const beatIndex = Math.floor(demoData.time) % demoData.beatPattern.length;
                
                // Get values from patterns with reduced intensity for mellower feel
                const bass = demoData.bassPattern[bassIndex] * 0.7; // Reduce intensity
                const mid = demoData.midPattern[midIndex] * 0.6;    // Reduce intensity
                const high = demoData.highPattern[highIndex] * 0.5;  // Reduce intensity
                const beat = demoData.beatPattern[beatIndex];
                
                // Calculate overall level with reduced intensity
                const level = (bass * 0.4 + mid * 0.2 + high * 0.1) * 0.7;
                
                // Update the level visualization
                document.querySelector('.level').style.width = `${level * 100}%`;
                
                return {
                    bass: bass,
                    mid: mid,
                    high: high,
                    beat: beat,
                    level: level,
                    energy: (bass + mid + high) / 4, // Further reduce energy level for mellower feel
                    beatFactor: beat ? 0.6 : bass * 0.4 // More subtle beat factor
                };
            }
            
            // Normal audio analysis when not in demo mode
            if (!audioInitialized) return { 
                bass: 0, mid: 0, high: 0, 
                beat: false, level: 0, 
                energy: 0, beatFactor: calculateFallbackBeatFactor() 
            };
            
            // Get frequency data
            audioAnalyser.getByteFrequencyData(dataArray);
            
            // Calculate energy in different frequency bands
            const nyquist = audioContext.sampleRate / 2;
            const freqByIndex = i => i * nyquist / dataArray.length;
            
            let bassTotal = 0, bassCount = 0;
            let midTotal = 0, midCount = 0;
            let highTotal = 0, highCount = 0;
            let overallTotal = 0;
            
            for (let i = 0; i < dataArray.length; i++) {
                const value = dataArray[i] / 255; // Normalize to 0-1
                const frequency = freqByIndex(i);
                
                overallTotal += value;
                
                if (frequency >= CONFIG.audioThresholds.bass[0] && frequency <= CONFIG.audioThresholds.bass[1]) {
                    bassTotal += value;
                    bassCount++;
                } else if (frequency >= CONFIG.audioThresholds.mid[0] && frequency <= CONFIG.audioThresholds.mid[1]) {
                    midTotal += value;
                    midCount++;
                } else if (frequency >= CONFIG.audioThresholds.high[0] && frequency <= CONFIG.audioThresholds.high[1]) {
                    highTotal += value;
                    highCount++;
                }
            }
            
            // Get averages
            bassEnergy = bassCount ? bassTotal / bassCount : 0;
            midEnergy = midCount ? midTotal / midCount : 0;
            highEnergy = highCount ? highTotal / highCount : 0;
            
            // Calculate overall level with smoothing
            const newLevel = overallTotal / dataArray.length;
            audioLevel = newLevel;
            smoothedLevel = smoothedLevel * 0.8 + newLevel * 0.2;
            
            // Beat detection
            // Store historical levels for relative comparison
            beatHistory.push(bassEnergy);
            if (beatHistory.length > 20) beatHistory.shift();
            
            // Calculate average and standard deviation
            const avg = beatHistory.reduce((a, b) => a + b, 0) / beatHistory.length;
            const variance = beatHistory.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / beatHistory.length;
            const threshold = avg + Math.sqrt(variance) * 0.8;
            
            // Detect beat when bass energy exceeds threshold
            const currentBeat = bassEnergy > threshold && bassEnergy > 0.15;
            
            // Only trigger once per beat
            let isBeat = false;
            if (currentBeat && !beatDetected) {
                beatDetected = true;
                isBeat = true;
            } else if (!currentBeat) {
                beatDetected = false;
            }
            
            // Calculate beat factor (how strong the beat is)
            let beatFactor = 0;
            if (isBeat) {
                // New beat detected
                beatFactor = 1;
            } else {
                // Decay current beat factor
                beatFactor = Math.max(0, beatFactor - 0.1);
            }
            
            // Update the level visualization
            document.querySelector('.level').style.width = `${audioLevel * 100}%`;
            
            return {
                bass: bassEnergy,
                mid: midEnergy,
                high: highEnergy,
                beat: isBeat,
                level: audioLevel,
                energy: (bassEnergy + midEnergy + highEnergy) / 3,
                beatFactor: isBeat ? 1 : Math.max(bassEnergy * 1.5, calculateFallbackBeatFactor() * 0.5)
            };
        }
        
        // Variables for touch gesture handling
        let touchStartDistance = 0;
        let isMultiTouch = false;
        
        // Handle touch start for pinch gesture
        function handleTouchStart(event) {
            if (event.touches.length === 2) {
                event.preventDefault();
                isMultiTouch = true;
                
                // Calculate distance between two touch points
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }
        
        // Handle touch move for pinch gesture
        function handleTouchMove(event) {
            if (isMultiTouch && event.touches.length === 2) {
                event.preventDefault();
                
                // Calculate new distance between touch points
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const touchEndDistance = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate zoom based on the pinch gesture
                const touchDelta = touchEndDistance - touchStartDistance;
                const zoomSpeed = 0.01;
                const delta = touchDelta * zoomSpeed;
                
                // Update camera zoom with constraints
                cameraZoom = Math.max(2, Math.min(10, cameraZoom - delta));
                
                // Update start distance for next move event
                touchStartDistance = touchEndDistance;
            }
        }
        
        // Handle touch end for pinch gesture
        function handleTouchEnd(event) {
            isMultiTouch = false;
        }
        
        // Handle mouse wheel for camera zoom
        function handleMouseWheel(event) {
            event.preventDefault();
            
            // Determine zoom direction and speed
            const zoomSpeed = 0.2;
            const delta = -Math.sign(event.deltaY) * zoomSpeed;
            
            // Update camera zoom with min/max constraints
            cameraZoom = Math.max(2, Math.min(10, cameraZoom + delta));
        }
        
        // Update camera with very slow tilting motion
        function updateCamera(deltaTime) {
            const time = clock.getElapsedTime();
            
            // Apply camera position with zoom
            camera.position.x = 0;
            camera.position.y = 0;
            camera.position.z = cameraZoom;
            
            // Create a very slow tilting effect by shifting where the camera looks
            // Rather than moving the camera itself, we'll adjust what it's looking at
            
            // For demo mode, use even slower and gentler camera movements
            const tiltSpeed = demoMode ? 0.002 : 0.005; // Extra slow tilt speed for demo mode
            
            // Calculate tilted look target
            // Start with the center object's position
            const targetX = centerObject.position.x + time * tiltSpeed * 0.02; // Slower rightward tilt
            const targetY = centerObject.position.y - time * tiltSpeed * 0.025; // Slower downward tilt
            const targetZ = centerObject.position.z;
            
            // Create a target Vector3 with subtle organic motion - even more subtle in demo mode
            const movementFactor = demoMode ? 0.005 : 0.01; // Reduced movement factor for demo mode
            const organicX = Math.sin(time * 0.008) * movementFactor;
            const organicY = Math.cos(time * 0.006) * movementFactor;
            const lookTarget = new THREE.Vector3(
                targetX + organicX,
                targetY + organicY,
                targetZ
            );
            
            // Make the camera look at this slowly moving target
            camera.lookAt(lookTarget);
        }
        
        // Create the star field with multiple depth layers
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                size: 0.3,
                sizeAttenuation: true,
                color: 0xFFFFFF,
                vertexColors: true
            });
            
            // Create star positions and colors
            const positions = [];
            const colors = [];
            const sizes = [];
            const starData = [];
            
            // Define depth layers for parallax effect - dramatically increased speed factors for faster travel
            const depthLayers = [
                { min: -200, max: -150, count: Math.floor(CONFIG.starCount * 0.3), speedFactor: 0.5, sizeFactor: 0.3 },  // Very far background
                { min: -150, max: -80, count: Math.floor(CONFIG.starCount * 0.3), speedFactor: 1.2, sizeFactor: 0.5 },  // Far background
                { min: -80, max: -30, count: Math.floor(CONFIG.starCount * 0.2), speedFactor: 3.5, sizeFactor: 0.7 },   // Mid background
                { min: -30, max: -1, count: Math.floor(CONFIG.starCount * 0.2), speedFactor: 8.0, sizeFactor: 0.9 }     // Foreground - extremely fast
            ];
            
            // Create stars for each depth layer
            depthLayers.forEach(layer => {
                for (let i = 0; i < layer.count; i++) {
                    // Random position in 3D space
                    const x = (Math.random() - 0.5) * 20;
                    const y = (Math.random() - 0.5) * 20;
                    const z = layer.min + Math.random() * (layer.max - layer.min); // Z based on depth layer
                    
                    positions.push(x, y, z);
                    
                    // Adjust star color based on depth (distant stars more blue/faded, closer stars more bright)
                    let r, g, b;
                    
                    if (layer.speedFactor <= 0.2) {
                        // Distant stars (bluish, faded)
                        r = 0.6 + Math.random() * 0.2;
                        g = 0.7 + Math.random() * 0.2;
                        b = 0.9 + Math.random() * 0.1;
                    } else if (layer.speedFactor <= 0.5) {
                        // Mid-distance stars (slightly purplish)
                        r = 0.7 + Math.random() * 0.2;
                        g = 0.7 + Math.random() * 0.2;
                        b = 0.9 + Math.random() * 0.1;
                    } else if (layer.speedFactor <= 1.0) {
                        // Closer stars (white)
                        r = 0.8 + Math.random() * 0.2;
                        g = 0.8 + Math.random() * 0.2;
                        b = 0.9 + Math.random() * 0.1;
                    } else {
                        // Foreground stars (slight yellow/white tint)
                        r = 0.9 + Math.random() * 0.1;
                        g = 0.9 + Math.random() * 0.1;
                        b = 0.8 + Math.random() * 0.1;
                    }
                    
                    colors.push(r, g, b);
                    
                    // Adjust star size based on depth layer
                    const baseSize = 0.1 + Math.random() * 0.2;
                    const adjustedSize = baseSize * layer.sizeFactor;
                    sizes.push(adjustedSize);
                    
                    // Store additional star data for animations
                    starData.push({
                        twinkleSpeed: 0.5 + Math.random() * 2,
                        twinkleOffset: Math.random() * Math.PI * 2,
                        explosionChance: Math.random() * 0.0001 * layer.speedFactor, // More explosions in foreground
                        originalSize: adjustedSize,
                        depthSpeedFactor: layer.speedFactor,
                        depthLayer: layer
                    });
                }
            });
            
            // Add attributes to geometry
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            // Create the star field mesh
            starField = new THREE.Points(starGeometry, starMaterial);
            starField.userData.starData = starData;
            scene.add(starField);
        }
        
        // Create the center geometric object
        function createCenterObject() {
            // Use a more detailed geometry with more segments to emphasize lines
            const geometry = new THREE.IcosahedronGeometry(0.5, 1); // Using icosahedron for more visible facets
            
            // Create primary material for the solid object
            const material = new THREE.MeshPhongMaterial({
                color: 0xff2233, // Vibrant red color from album cover
                emissive: 0xcc1122, // Deep red emissive glow
                flatShading: true, // Enable flat shading to emphasize facets
                shininess: 120
            });
            
            // Create the main mesh
            centerObject = new THREE.Mesh(geometry, material);
            
            // Create a wireframe mesh that overlays the main mesh
            const wireframeMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff, // White lines
                linewidth: 2, // Thicker lines (note: line width beyond 1 may not work in all browsers)
                opacity: 0.8, // Slightly transparent
                transparent: true
            });
            
            // Create wireframe geometry from the original geometry
            const wireframeGeometry = new THREE.WireframeGeometry(geometry);
            const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
            
            // Add wireframe as a child of the main mesh
            centerObject.add(wireframe);
            
            // Position slightly forward to enhance the flying effect
            centerObject.position.z = 1.5;
            scene.add(centerObject);
            
            // Initialize the annotation's position
            initializeAnnotation();
            
            // Add a light for the center object
            const light = new THREE.PointLight(0xff2233, 1.8, 10); // Brighter light with exact red color
            light.position.set(0, 0, 3); // Position further forward
            scene.add(light);
            
            // Create multiple trail lights for enhanced trail effect
            const trailLight1 = new THREE.PointLight(0xff2233, 1.2, 6);
            trailLight1.position.set(0, 0, -1.5); // First trail light
            scene.add(trailLight1);
            
            const trailLight2 = new THREE.PointLight(0xff3344, 0.8, 4);
            trailLight2.position.set(0, 0, -3); // Second trail light
            scene.add(trailLight2);
            
            const trailLight3 = new THREE.PointLight(0xff4455, 0.6, 3);
            trailLight3.position.set(0, 0, -4.5); // Third trail light 
            scene.add(trailLight3);
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);
        }
        
        // Update stars with depth-based parallax movement and audio reactivity
        function updateStars(deltaTime, audioData) {
            const positions = starField.geometry.attributes.position;
            const sizes = starField.geometry.attributes.size;
            const colors = starField.geometry.attributes.color;
            const starData = starField.userData.starData;
            
            // Adjust speed factor based on mode - slower and gentler in demo mode
            // This creates a more mellow, dreamy starfield effect in demo mode
            const baseFactor = demoMode ? 0.8 : 2.5; // Reduced speed in demo mode for mellower feel
            
            for (let i = 0; i < starData.length; i++) {
                const i3 = i * 3;
                
                // Get current position for depth check
                const z = positions.array[i3 + 2];
                
                // Apply speed based on depth layer and mode
                // In demo mode, we reduce the speed for a more ambient, mellow experience
                const modeSpeedMultiplier = demoMode ? 0.4 : 1.0; // 60% slower in demo mode
                const movementSpeed = CONFIG.starSpeed * starData[i].depthSpeedFactor * baseFactor * modeSpeedMultiplier;
                positions.array[i3 + 2] += movementSpeed * deltaTime;
                
                // Reset star position when it passes camera
                const depthLayer = starData[i].depthLayer;
                if (positions.array[i3 + 2] > 5) {
                    // Use a narrower range for x and y as distance increases for a tunnel-like effect
                    // This creates a perspective where stars appear to come from a central point in the distance
                    const distanceFactor = 1 + Math.abs(depthLayer.min) / 50; // Larger value for more distant stars
                    positions.array[i3] = (Math.random() - 0.5) * 40 / distanceFactor;
                    positions.array[i3 + 1] = (Math.random() - 0.5) * 40 / distanceFactor;
                    positions.array[i3 + 2] = depthLayer.min; // Reset to back of its layer
                    
                    // Reset star data
                    starData[i].twinkleOffset = Math.random() * Math.PI * 2;
                }
                
                // Twinkle effect with audio reactivity
                const twinkleFactor = Math.max(0.3, Math.min(1, starData[i].depthSpeedFactor));
                const twinkle = Math.sin(clock.elapsedTime * starData[i].twinkleSpeed + starData[i].twinkleOffset);
                const twinkleAmount = 0.2 * (0.5 + 0.5 * twinkle) * twinkleFactor;
                
                // Apply audio influence to twinkling (more influence on closer stars)
                // Use high frequencies for twinkling
                const audioInfluence = 0.3 * audioData.high * starData[i].depthSpeedFactor;
                const beatInfluence = 0.2 * audioData.beatFactor * starData[i].depthSpeedFactor;
                const totalTwinkle = twinkleAmount + audioInfluence + beatInfluence;
                
                // Update size with twinkle and audio
                sizes.array[i] = starData[i].originalSize * (1 + totalTwinkle);
                
                // Star explosions based on audio beats
                const baseExplosionChance = CONFIG.explosionFrequency * starData[i].depthSpeedFactor;
                // Increase explosion chance during beats
                const explosionChance = baseExplosionChance * (1 + audioData.beatFactor * 5);
                
                if (Math.random() < explosionChance * deltaTime || 
                    (audioData.beat && Math.random() < starData[i].depthSpeedFactor * 0.1)) {
                    // More dramatic explosions for closer stars and louder audio
                    const explosionSize = 3 + 2 * starData[i].depthSpeedFactor * (1 + audioData.level);
                    sizes.array[i] = starData[i].originalSize * explosionSize;
                    
                    // Explosion color based on frequency energy
                    // Use mid frequencies for color shift
                    const colorShift = Math.min(1, audioData.mid * 1.5);
                    
                    if (starData[i].depthSpeedFactor <= 0.2) {
                        // Distant explosion (blue-ish)
                        colors.array[i3] = 0.6 + colorShift * 0.2;
                        colors.array[i3 + 1] = 0.7;
                        colors.array[i3 + 2] = 1.0;
                    } else if (starData[i].depthSpeedFactor <= 0.5) {
                        // Mid-distance explosion (purple-ish)
                        colors.array[i3] = 0.8 + colorShift * 0.2;
                        colors.array[i3 + 1] = 0.7 - colorShift * 0.2;
                        colors.array[i3 + 2] = 1.0;
                    } else if (starData[i].depthSpeedFactor <= 1.0) {
                        // Closer explosion (white)
                        colors.array[i3] = 1.0;
                        colors.array[i3 + 1] = 1.0;
                        colors.array[i3 + 2] = 1.0;
                    } else {
                        // Foreground explosion (yellow/white tint)
                        colors.array[i3] = 1.0;
                        colors.array[i3 + 1] = 1.0;
                        colors.array[i3 + 2] = 0.8 - colorShift * 0.3;
                    }
                } else {
                    // Gradually return to original color based on depth layer
                    if (starData[i].depthSpeedFactor <= 0.2) {
                        // Distant stars (bluish)
                        colors.array[i3] = 0.6 + 0.2 * Math.random();
                        colors.array[i3 + 1] = 0.7 + 0.2 * Math.random();
                        colors.array[i3 + 2] = 0.9 + 0.1 * Math.random();
                    } else if (starData[i].depthSpeedFactor <= 0.5) {
                        // Mid-distance stars (slightly purplish)
                        colors.array[i3] = 0.7 + 0.2 * Math.random();
                        colors.array[i3 + 1] = 0.7 + 0.2 * Math.random();
                        colors.array[i3 + 2] = 0.9 + 0.1 * Math.random();
                    } else if (starData[i].depthSpeedFactor <= 1.0) {
                        // Closer stars (white)
                        colors.array[i3] = 0.8 + 0.2 * Math.random();
                        colors.array[i3 + 1] = 0.8 + 0.2 * Math.random();
                        colors.array[i3 + 2] = 0.9 + 0.1 * Math.random();
                    } else {
                        // Foreground stars (slight yellow/white tint)
                        colors.array[i3] = 0.9 + 0.1 * Math.random();
                        colors.array[i3 + 1] = 0.9 + 0.1 * Math.random();
                        colors.array[i3 + 2] = 0.8 + 0.1 * Math.random();
                    }
                }
            }
            
            positions.needsUpdate = true;
            sizes.needsUpdate = true;
            colors.needsUpdate = true;
        }
        
        // Update the center object with audio reactivity
        function updateCenterObject(deltaTime, audioData) {
            // Rotation speed affected by mid-range frequencies
            const rotSpeedX = 0.08 * (1 + audioData.mid * CONFIG.audioReactivity * 2);
            const rotSpeedY = 0.12 * (1 + audioData.mid * CONFIG.audioReactivity * 2);
            const rotSpeedZ = 0.05 * (1 + audioData.mid * CONFIG.audioReactivity * 2);
            
            centerObject.rotation.x += rotSpeedX * deltaTime;
            centerObject.rotation.y += rotSpeedY * deltaTime;
            centerObject.rotation.z += rotSpeedZ * deltaTime;
            
            // More dynamic floating motion for flying effect
            const time = clock.getElapsedTime();
            // Reduced Z movement to keep position more stable for flying effect
            // Increased X/Y movement for more dynamic flying pattern
            const floatY = Math.sin(time * 0.7) * 0.25;
            const floatX = Math.sin(time * 0.5) * 0.18;
            const floatZ = 1.5 + Math.cos(time * 0.3) * 0.05; // Keep fairly stable on Z to maintain flying forward
            
            // Add audio reactivity to position (bass frequencies move the object)
            const audioFloatY = audioData.bass * 0.2 * CONFIG.audioReactivity;
            const audioFloatX = audioData.bass * 0.1 * CONFIG.audioReactivity;
            const audioFloatZ = audioData.bass * 0.15 * CONFIG.audioReactivity;
            
            centerObject.position.set(
                floatX + audioFloatX, 
                floatY + audioFloatY, 
                floatZ + audioFloatZ
            );
            
            // Pulse size based on audio
            // Base slow pulse
            const slowPulse = Math.sin(time * 0.1) * 0.5 + 0.5;
            const mediumPulse = Math.sin(time * 0.2) * 0.3 + 0.5;
            const combinedPulse = 0.7 * slowPulse + 0.3 * mediumPulse;
            
            // Add audio influence - use bass and beat for pulsing
            const audioPulse = audioData.bass * 0.5 + audioData.beatFactor * 0.5;
            const pulseSize = 1 + (CONFIG.objectPulseAmount * 0.5 * combinedPulse) + 
                            (CONFIG.objectPulseAmount * CONFIG.audioReactivity * audioPulse);
            
            // Apply non-uniform scaling for more organic feel - exaggerate on audio beat
            const beatFactor = audioData.beatFactor * CONFIG.audioReactivity;
            const xScale = pulseSize * (1 + Math.sin(time * 0.19) * 0.05 + beatFactor * 0.1);
            const yScale = pulseSize * (1 + Math.sin(time * 0.23) * 0.05 + beatFactor * 0.2);
            const zScale = pulseSize * (1 + Math.sin(time * 0.17) * 0.05 + beatFactor * 0.15);
            centerObject.scale.set(xScale, yScale, zScale);
            
            // Color shifts based on audio frequencies
            const material = centerObject.material;
            
            // Base color cycle that shifts between cool tones
            const hue = (Math.sin(time * 0.05) * 0.1 + 0.6) % 1; // Blue spectrum
            const saturation = 0.7 + Math.sin(time * 0.065) * 0.3;
            const lightness = 0.5 + Math.sin(time * 0.035) * 0.2;
            
            // Audio influence on color
            // Bass affects hue, mid affects saturation, high affects lightness
            const hueShift = audioData.bass * 0.2 * CONFIG.audioReactivity;
            const satShift = audioData.mid * 0.3 * CONFIG.audioReactivity;
            const lightShift = audioData.high * 0.2 * CONFIG.audioReactivity;
            
            // Create HSL color with audio influence
            const baseColor = new THREE.Color().setHSL(
                (hue + hueShift) % 1, 
                Math.min(1, saturation + satShift), 
                Math.min(1, lightness + lightShift)
            );
            
            // Create accent color - shift further during beats
            const accentHue = (hue + 0.1 + hueShift + audioData.beatFactor * 0.1) % 1;
            const accentColor = new THREE.Color().setHSL(
                accentHue,
                Math.min(1, saturation + satShift + 0.1),
                Math.min(1, lightness + lightShift + 0.2)
            );
            
            // Mix colors based on beat
            const beatInfluence = audioData.beatFactor * 0.5 + combinedPulse * 0.2;
            const finalColor = baseColor.clone().lerp(accentColor, beatInfluence);
            
            material.color.copy(finalColor);
            material.emissive.copy(finalColor).multiplyScalar(0.4 + audioData.level * 0.6);
        }
        
        // Calculate fallback beat factor (when no audio)
        function calculateFallbackBeatFactor() {
            const elapsed = clock.getElapsedTime();
            const beatTime = elapsed % BEAT_INTERVAL;
            const beatProgress = beatTime / BEAT_INTERVAL;
            
            // Smoother attack and decay for hypnotic feel
            const sineInfluence = Math.sin(beatProgress * Math.PI) * 0.5 + 0.5;
            const expDecay = Math.max(0, 1 - Math.pow(beatProgress * 2.5, 1.8));
            
            // Blend between sine and exponential for a more organic feel
            return expDecay * 0.7 + sineInfluence * 0.3;
        }
        
        // Create particle system for star debris effect
        function createParticleSystem() {
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({ 
                color: 0xFFFFFF,
                size: 0.05,
                transparent: true,
                opacity: 0.8,
                vertexColors: true
            });
            
            // Initialize arrays for particle attributes
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            
            // Initialize particle data
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                
                // Initially position particles off-screen
                positions[i3] = 0;
                positions[i3 + 1] = 0;
                positions[i3 + 2] = 1000; // Far away (inactive)
                
                // Assign default white color
                colors[i3] = 1.0;
                colors[i3 + 1] = 1.0;
                colors[i3 + 2] = 1.0;
                
                // Store additional particle data
                particleData.push({
                    active: false,
                    velocity: new THREE.Vector3(),
                    life: 0,
                    maxLife: 0
                });
            }
            
            // Set buffer attributes
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create the particle system
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
        }
        
        // Update particle system
        function updateParticleSystem(deltaTime, audioData) {
            const positions = particleSystem.geometry.attributes.position;
            const colors = particleSystem.geometry.attributes.color;
            
            // Activate new particles based on audio reactivity and random chance
            const activationChance = 0.04 * (1 + audioData.beat * 2); 
            
            // Process active particles
            for (let i = 0; i < particleData.length; i++) {
                const i3 = i * 3;
                const particle = particleData[i];
                
                if (particle.active) {
                    // Update position based on velocity
                    positions.array[i3] += particle.velocity.x * deltaTime;
                    positions.array[i3 + 1] += particle.velocity.y * deltaTime;
                    positions.array[i3 + 2] += particle.velocity.z * deltaTime;
                    
                    // Update life
                    particle.life -= deltaTime;
                    
                    // Fade out based on remaining life
                    const alpha = particle.life / particle.maxLife;
                    colors.array[i3 + 2] = alpha; // Fade to blue as they age
                    
                    // Deactivate if life is over
                    if (particle.life <= 0) {
                        particle.active = false;
                        positions.array[i3 + 2] = 1000; // Move off-screen
                    }
                } else if (Math.random() < activationChance * deltaTime) {
                    // Try to activate a new particle
                    // Find a suitable star to break off from
                    const starPositions = starField.geometry.attributes.position;
                    const starColors = starField.geometry.attributes.color;
                    const starData = starField.userData.starData;
                    
                    // Randomly select a star
                    const starIndex = Math.floor(Math.random() * starData.length);
                    const starI3 = starIndex * 3;
                    
                    // Only create particles for stars that are close enough to be visible
                    const starZ = starPositions.array[starI3 + 2];
                    if (starZ > -50 && starZ < 3) { // Only mid-range to close stars
                        // Activate particle
                        particle.active = true;
                        
                        // Position slightly offset from the star
                        positions.array[i3] = starPositions.array[starI3] + (Math.random() - 0.5) * 0.2;
                        positions.array[i3 + 1] = starPositions.array[starI3 + 1] + (Math.random() - 0.5) * 0.2;
                        positions.array[i3 + 2] = starPositions.array[starI3 + 2];
                        
                        // Copy star color for the particle
                        colors.array[i3] = starColors.array[starI3];
                        colors.array[i3 + 1] = starColors.array[starI3 + 1];
                        colors.array[i3 + 2] = starColors.array[starI3 + 2];
                        
                        // Set velocity - drift away from the star with some randomness
                        const driftSpeed = 0.5 + Math.random() * 1.5;
                        particle.velocity.set(
                            (Math.random() - 0.5) * driftSpeed,
                            (Math.random() - 0.5) * driftSpeed,
                            2 + Math.random() * 3 // Main direction is toward camera
                        );
                        
                        // Set life span
                        particle.maxLife = 0.5 + Math.random() * 1.0;
                        particle.life = particle.maxLife;
                    }
                }
            }
            
            // Update the geometry attributes
            positions.needsUpdate = true;
            colors.needsUpdate = true;
        }
        
        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min(0.1, clock.getDelta()); // Cap delta time to avoid large jumps
            
            // Get audio data
            const audioData = analyzeAudio();
            
            // Update camera
            updateCamera(deltaTime);
            
            // Update scene elements with audio data
            updateStars(deltaTime, audioData);
            updateParticleSystem(deltaTime, audioData);
            updateCenterObject(deltaTime, audioData);
            updateAnnotation(); // Update the annotation position
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Initialize the application
        init();
    </script>
</body>
</html>